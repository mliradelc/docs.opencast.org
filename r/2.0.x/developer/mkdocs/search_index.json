{
    "docs": [
        {
            "location": "/",
            "text": "Matterhorn Development Guides\n\n\nThese guides will help you if you want to participate in Matterhorn development.\n\n\n\n\nDevelopment Process\n\n\nReviewing, Merging and Declining Pull Requests\n\n\nRelease Manager\n\n\n\n\n\n\nProposal Log\n\n\nLicenses and Legal Matters\n\n\nPackaging Guidelines",
            "title": "Home"
        },
        {
            "location": "/#matterhorn-development-guides",
            "text": "These guides will help you if you want to participate in Matterhorn development.   Development Process  Reviewing, Merging and Declining Pull Requests  Release Manager    Proposal Log  Licenses and Legal Matters  Packaging Guidelines",
            "title": "Matterhorn Development Guides"
        },
        {
            "location": "/development/",
            "text": "Development Process\n\n\nThis document defines rules and recommendations for Opencast development. In particular, it defines how patches can be\ncontributed, how they are merged and how releases are done.\n\n\nIf this document does not answer all of your questions, here is how you can get further help:\n\n\n\n\nAsk on the \nOpencast Development List\n\n\nChat with developers on \nIRC (#opencast on freenode)\n\n\nJoin our weekly technical meeting (see lists or IRC)\n\n\n\n\nContributing Code\n\n\nOpencast sources can be found on \nBitBucket\n. The easiest way to contribute\ncode to the project is by creating a pull request against the project's official repository. More details about the\nstructure of this repository are explained later in this guide.\n\n\nJira and BitBucket\n\n\n\n\n\n\nOpencast uses \nJira\n for tracking issues. Each pull request should be accompanied by a\n   ticket in Jira. The issue identifier should also be used in the title of the pull request and the commits. E.g.:\n   \nMH-12345, Fixing Something Somewhere\n. Creating a Jira ticket is usually the first step when fixing something.\n\n\n\n\n\n\nOpencast uses \nBitBucket\n for code hosting. Please\n   \nfork\n the official\n   repository on BitBucket to \ncreate pull\n   requests\n from your repository\n   which will show up on the project's list of open pull requests.\n\n\n\n\n\n\nAll open pull requests are listed on the \nOpencast Pull Request Filter\n. It might\n   take a couple of minutes for a new pull request to show up.\n\n\n\n\n\n\nBugfix vs Feature\n\n\nOpencast distinguishes between bug fix and feature pull requests.\n\n\n\n\n\n\nFeatures are \nonly\n allowed to be merged into \ndevelop\n, which will let them automatically become part of the next\n   major/minor release, given that the release branch for the next release has not been cut yet. If possible, please\n   name branches containing features according to the pattern \nf/MH-XXXXX-short-description\n, where MH-XXXXX is the\n   relevant Jira ticket.\n\n\n\n\n\n\nBug fixes can be merged both into \ndevelop\n and into release branches. If possible, please name branches containing\n   bug fixes according to the pattern \nt/MH-XXXXX-short-description\n, where MH-XXXXX is the relevant Jira ticket.\n\n\n\n\n\n\nReviews\n\n\nBefore a patch is merged, it needs to be reviewed by a committer. The reviewer makes sure that the patch merges\nwithout conflicts, that it works as expected and that it does not break anything else.\n\n\nIf the reviewer discovers any kind of issue, he should comment on the pull request in BitBucket, so that the author can\nfix the problem.\n\n\nFor more details about the review and merge process, have a look at \nReviewing, Merging and Declining Pull\nRequests\n.\n\n\nCoding Rules\n\n\nMaven will automatically check for coding style violations and interrupt the process if it founds any, displaying a\nmessage about it. Apart from that, here are some general rules:\n\n\nJava:\n\n\n\n\nIndentation is done with exactly two spaces\n\n\nNo line of code should be wider than 120 columns\n\n\nAvoid trailing spaces\n\n\nAvoid unnecessary code style changes\n\n\n\n\nGit Repository Branching Model\n\n\nWhile the Opencast repository and branching model is inspired by\n\nGitFlow\n, there have been some distinct changes to how release\nbranches are used and releases are tagged. The purpose of this is mainly to support multiple, simultaneous versions and\nmaintenance releases.\n\n\nSwift overview:\n\n\n\n\nThe \ndevelop\n branch represents the latest state of development. Features may be merged into this branch and into\n   this branch only. Release branches are branched off from \ndevelop\n. It is basically the preparation for the next big\n   release at all times.\n\n\nThe release branches are named \nr/<a>.<b>.x\n (e.g. \nr/1.6.x\n). They are the latest state of development for a\n   specific release. Only bug fixes and no features may be added to these branches. All beta versions, release\n   candidates and final releases are made from these branches. The branch lives on as long as there may be additional\n   maintenance releases for a given version.\n\n\nGit tags are created to indicate official releases. These may be:\n\n\nx.y.z-betaX\n marks a beta release. This is usually a version which may still have bugs but is good enough for\n  testing, so that further issues or bugs can be identified before an actual release.\n\n\nx.y.z-rcX\n marks a release candidate. This is a version that seems to be ready to be released as a final\n  version. It will become the final version if testing does not reveal any severe issues.\n\n\nx.y.z\n marks a final release.\n\n\n\n\n\n\n\n\nTo get a closer look at the branching model, let us consider a simple example with a single release:\n\n\ndevelop ---*----*----*------*------- ... -----------*-->\n            \\       /      /                       /\n    r/1.6.x  *-----*------*-------------*---------*----- ... ---*-->\n                           \\             \\         \\             \\\n                1.6.0-beta1 *   1.6.0-rc1 *   1.6.0 *       1.6.1 *\n\n\n\nAs described above, \ndevelop\n is the branch used for preparing the next version. At some point marked in the release\nschedule, the release branch is cut from \ndevelop\n. This action also marks the feature freeze for such Opencast version,\ni.e. the moment when no new features will be included in that specific version. This is because all the new features\nmust be merged only into the \ndevelop\n branch; therefore, the release branches (such as \nr/1.6.x\n in our example) can\nonly contain features that were merged before the branch was forked off. Any features merged after the creation of the\nrelease branch can only make it into the next release, but not into this one.\n\n\nAfter the release branch is cut, the development on the \ndevelop\n branch may continue as before. Features can (and\nshould) be merged without waiting for the next version to be released. Thus, the creation of a release branch also marks\nthe beginning of the development for the next version.\n\n\nIn contrast to that, only bug fixes can be merged in the release branch. At this point, the code contained in this\nbranch should be tested, so that bugs can be identified and fixed. The release manager can tag different beta versions\nduring the QA process (such as \n1.6.0-beta1\n) to mark the code evolution as bug fixes are merged. Once the branch status\nseems to be stable enough to be released, a release candidate (RC) is tagged and tested (\n1.6.0-rc1\n). New RCs can be\ntagged as long as new issues are found and fixed. When no severe issues are found, the final release is tagged.\n\n\nDuring the whole process the release manager will regularly merge back the release branch into \ndevelop\n so that bug\nfixes from the release branch will automatically become part of \ndevelop\n and the next Opencast version, without having\nto create an additional pull request. This is continued until the release branch for the next version is cut.\n\n\nThe releases themselves are not part of the release branch. Instead, the release manager branches off, makes the\nnecessary changes to the pom files (and possibly the UI) and creates a separate tagged commit.\n\n\nFinally, after a release is done, more bug fixes may be added to the release branch. The release manager should identify\nif there are enough commits to be put into a maintenance release.\n\n\nEven after an Opencast version has been released, more bugs may be found and fixes for them merged in the release\nbranch. When the release manager considers that the number or importance of such bug fixes is sufficient, he may decide\nto create a new maintenance release. The version \n1.6.1\n above is an example of that.\n\n\nThe branching structure for multiple versions does not look much more complicated:\n\n\ndevelop  -----*---------*----*------------------------*------>\n               \\       /    / \\                      /\n        r/1.5.x *-----*----*------------*--->       /\n                       \\        \\        \\         /\n                  1.5.0 *        \\  1.5.1 *       /\n                                  \\              /\n                           r/1.6.x *------------*----->\n                                                 \\\n                                            1.6.0 *\n\n\n\nAs you can see, the same principle, the same structure and the same rules apply. The only noteworthy thing is that,\nafter a new release branch is cut, the old release branch will not be merged back into \ndevelop\n. This means that when\na bug fix is relevant to several releases, a different pull request should be created for each of the release branches.\n\n\nRelease Process\n\n\nAs indicated above, the release cycle of a new Opencast version starts when a release branch is cut. The new features\nmerged into \ndevelop\n afterwards will be part of the next version, but not the one just cut.\n\n\nThis is why the position of release manager for the next Opencast version should be assigned at this point. The current\nrelease manager should therefore ask for volunteers in the mailing lists. For more details about the rights and\nresponsibilities of a release manager, please have a look at the \nRelease Manager Guide\n.\n\n\nPreparations\n\n\nThe first phase of the release consists of adding new features and defining the release schedule. It is the duty of the\nrelease manager to orchestrate this. This does not necessarily mean that release managers merge or review pull requests,\nbut that they talk to developers and ensure the merge process is driven forward.\n\n\nRelease Schedule\n\n\nReleases should happen twice a year, usually within a time span of 9.5 months between the cut of the previous release\nbranch and the final release. The release manager should create a release schedule as soon as possible, identifying when\nthe release branch is cut and when the final release will happen. Additionally, he should coordinate with the QA manager\nto identify phases for internal and public testing.\n\n\nUsually a release schedule will look like this:\n\n\nOctober 1st                     Cutting the release branch\nOctober 1st - 22nd              Internal QA phase\nOctober 22nd-November 5th       Public QA phase\nNovember 5th - 26th             Additional bug fixing phase\nNovember 26th - December 10th   Final QA phase (*)\nDecember 15th                   Release of Opencast x.y\n\n\n\n(*) marks the phase where the release is apparently ready to go and has no release blockers left. The additional time is\nto ensure that there is time to fix any serious bug found during this final phase.\n\n\nRelease Branch\n\n\nThe release branch is created from \ndevelop\n. The release branch is named \nr/A.B.x\n (e.g. \nr/2.1.x\n) to indicate that it\nis the origin of all releases with the major and minor version of \nA.B\n. The creation of the release branch marks the\nfeature freeze for a given version, as no more features can be merged into a release branch.\n\n\nTo ensure that all fixes that go into the release branch will become part of \ndevelop\n (and thus part of the next version\nof Opencast) with a minimum amount of work, the release manager will merge the release branch into \ndevelop\n on a\nregular basis. He may request assistance from certain developers in case of merge conflicts. This process continues until\nthe next release branch is cut.\n\n\nTags\n\n\nGit tags are used to mark explicit Opencast versions or releases. Here is how a release should look like in the history:\n\n\nr/A.B.x  ------------(A)---->\n                       \\\n           A.B.0-beta1 (B)\n\n\n\nTo create a version based on a given state of the release branch (commit A), the release manager will branch off from\nthis commit, make the necessary version changes to all \npom.xml\n files and to the UI and create a commit and a \nsigned\n\ngit tag on this commit. He would then push the commit and the tag (not the branch) to the community repository.\n\n\nFore more details about how to create release, have a look at the \nRelease Manager Guide\n.\n\n\nBeta Versions/Release Candidates\n\n\nA beta release (\nA.B.C-betaX\n) should be cut before the public QA phase. It indicates a specific version of Opencast for\nusers to test. It is expected to still have bugs. Beta releases should continue until all bugs with a severity of\n\nBlocker\n have been fixed.\n\n\nIf the code seems to be ready for a release, a \nrelease candidate\n (\nA.B.C-rcX\n) should be cut for final testing. The\ncommit from which a release candidate is created is expected to become the final release if no severe bugs are found.\n\n\nFinal Release\n\n\nOnce a release candidate seems to be stable during the QA phase (no issues left marked as \nBlocker\n), the release manager\nwill propose this release candidate to become the final release. If the proposal is approved (i.e. no serious bugs are\nfound before the proposal deadline is met), the final release is then created from the same commit the\nrelease candidate was cut from.\n\n\nMaintenance Releases\n\n\nAfter a final release, additional issues may show up. These issues may be fixed on the ongoing release branch and at\nsome point released as maintenance release.\n\n\nThere is usually no release schedule for maintenance releases. It is up to the release manager to decide when it is\nworthwhile to create a maintenance release with the fixes for bugs affecting a given release. He would then announce his\nintention to create such a release, cut a release candidate and, should no severe issues with this candidate show up, cut\nthe maintenance release.\n\n\nQuality Assurance\n\n\nAs any piece of software, Opencast may contain bugs. It is the duty of the whole community to identify these bugs,\nreport them and possibly fix them to improve Opencast as product.\n\n\nAdditionally, before releasing a new version of Opencast, the current release manager and quality assurance manager will\ncoordinate test phases dedicated to new releases in order to identify possible problems ahead of time. The whole\ncommunity will be requested to participate in this testing.\n\n\nReporting Bugs\n\n\nIf you identify any bugs, please report them! To do that, register yourself in the \nOpencast\nJira\n and create a new ticket. Please describe in detail how to reproduce the problem and\nespecially set the \nAffects Version\n and \"Fix Version\", where \nFix Version\n should be the next Opencast release.\n\n\nIf in doubt of any items in the ticket, please assign it for review to either the current release manager or to the\nquality assurance manager. They will check the issue fields and adjust \nfix version\n, \nseverity\n, etc. if necessary.\n\n\nSecurity Issues\n\n\nIf you discover a problem that has severe implications for system security, please do not publish these information on\nlist. Instead, send a report of the problem to \nsecurity@opencast.org\n. The message will be forwarded to the private\ncommitters list, where the issue will be discussed. Once a patch for the problem is ready, a security notice will be\nreleased along with it.\n\n\nUnit Tests\n\n\nAll Opencast modules should have built-in unit tests to check that they are actually doing what they are supposed to do\nand that code patches do not break the existing functionality. These tests are automatically run whenever the project is\nbuilt. If building repeatedly fails due to test failures, then something is most likely wrong. Please report this as a\nsevere bug.\n\n\nUser Tests\n\n\nBefore each major release, the release and quality assurance managers will ask the whole community to participate in\nthe execution of a set of manual tests. These tests are designed to check that important functionalities of Opencast\nwork as expected even if users are in slightly different environments or choose different methods to achieve a certain\ngoal.\n\n\nSuch a call for participation will usually be raised both on the lists, the technical and the adopters meeting.  If it\nis possible for you to participate, please do so. Identifying possible problems early will immensely benefit the release\nprocess.\n\n\nTest Server\n\n\nSome institutions provide public testing infrastructure for Opencast. Use them to try out the most recent development\nversion of Opencast. They are meant for testing. Do not fear to break them.  If you manage to do it, please contact the\nQA manager or send a notice to the list.\n\n\nRemember that they are usually not running a stable version of Opencast but the latest development release (beta version\nor release candidate) instead. If you discover any bugs on these systems, please take a minute to report them.",
            "title": "Development Process"
        },
        {
            "location": "/development/#development-process",
            "text": "This document defines rules and recommendations for Opencast development. In particular, it defines how patches can be\ncontributed, how they are merged and how releases are done.  If this document does not answer all of your questions, here is how you can get further help:   Ask on the  Opencast Development List  Chat with developers on  IRC (#opencast on freenode)  Join our weekly technical meeting (see lists or IRC)",
            "title": "Development Process"
        },
        {
            "location": "/development/#contributing-code",
            "text": "Opencast sources can be found on  BitBucket . The easiest way to contribute\ncode to the project is by creating a pull request against the project's official repository. More details about the\nstructure of this repository are explained later in this guide.",
            "title": "Contributing Code"
        },
        {
            "location": "/development/#jira-and-bitbucket",
            "text": "Opencast uses  Jira  for tracking issues. Each pull request should be accompanied by a\n   ticket in Jira. The issue identifier should also be used in the title of the pull request and the commits. E.g.:\n    MH-12345, Fixing Something Somewhere . Creating a Jira ticket is usually the first step when fixing something.    Opencast uses  BitBucket  for code hosting. Please\n    fork  the official\n   repository on BitBucket to  create pull\n   requests  from your repository\n   which will show up on the project's list of open pull requests.    All open pull requests are listed on the  Opencast Pull Request Filter . It might\n   take a couple of minutes for a new pull request to show up.",
            "title": "Jira and BitBucket"
        },
        {
            "location": "/development/#bugfix-vs-feature",
            "text": "Opencast distinguishes between bug fix and feature pull requests.    Features are  only  allowed to be merged into  develop , which will let them automatically become part of the next\n   major/minor release, given that the release branch for the next release has not been cut yet. If possible, please\n   name branches containing features according to the pattern  f/MH-XXXXX-short-description , where MH-XXXXX is the\n   relevant Jira ticket.    Bug fixes can be merged both into  develop  and into release branches. If possible, please name branches containing\n   bug fixes according to the pattern  t/MH-XXXXX-short-description , where MH-XXXXX is the relevant Jira ticket.",
            "title": "Bugfix vs Feature"
        },
        {
            "location": "/development/#reviews",
            "text": "Before a patch is merged, it needs to be reviewed by a committer. The reviewer makes sure that the patch merges\nwithout conflicts, that it works as expected and that it does not break anything else.  If the reviewer discovers any kind of issue, he should comment on the pull request in BitBucket, so that the author can\nfix the problem.  For more details about the review and merge process, have a look at  Reviewing, Merging and Declining Pull\nRequests .",
            "title": "Reviews"
        },
        {
            "location": "/development/#coding-rules",
            "text": "Maven will automatically check for coding style violations and interrupt the process if it founds any, displaying a\nmessage about it. Apart from that, here are some general rules:  Java:   Indentation is done with exactly two spaces  No line of code should be wider than 120 columns  Avoid trailing spaces  Avoid unnecessary code style changes",
            "title": "Coding Rules"
        },
        {
            "location": "/development/#git-repository-branching-model",
            "text": "While the Opencast repository and branching model is inspired by GitFlow , there have been some distinct changes to how release\nbranches are used and releases are tagged. The purpose of this is mainly to support multiple, simultaneous versions and\nmaintenance releases.  Swift overview:   The  develop  branch represents the latest state of development. Features may be merged into this branch and into\n   this branch only. Release branches are branched off from  develop . It is basically the preparation for the next big\n   release at all times.  The release branches are named  r/<a>.<b>.x  (e.g.  r/1.6.x ). They are the latest state of development for a\n   specific release. Only bug fixes and no features may be added to these branches. All beta versions, release\n   candidates and final releases are made from these branches. The branch lives on as long as there may be additional\n   maintenance releases for a given version.  Git tags are created to indicate official releases. These may be:  x.y.z-betaX  marks a beta release. This is usually a version which may still have bugs but is good enough for\n  testing, so that further issues or bugs can be identified before an actual release.  x.y.z-rcX  marks a release candidate. This is a version that seems to be ready to be released as a final\n  version. It will become the final version if testing does not reveal any severe issues.  x.y.z  marks a final release.     To get a closer look at the branching model, let us consider a simple example with a single release:  develop ---*----*----*------*------- ... -----------*-->\n            \\       /      /                       /\n    r/1.6.x  *-----*------*-------------*---------*----- ... ---*-->\n                           \\             \\         \\             \\\n                1.6.0-beta1 *   1.6.0-rc1 *   1.6.0 *       1.6.1 *  As described above,  develop  is the branch used for preparing the next version. At some point marked in the release\nschedule, the release branch is cut from  develop . This action also marks the feature freeze for such Opencast version,\ni.e. the moment when no new features will be included in that specific version. This is because all the new features\nmust be merged only into the  develop  branch; therefore, the release branches (such as  r/1.6.x  in our example) can\nonly contain features that were merged before the branch was forked off. Any features merged after the creation of the\nrelease branch can only make it into the next release, but not into this one.  After the release branch is cut, the development on the  develop  branch may continue as before. Features can (and\nshould) be merged without waiting for the next version to be released. Thus, the creation of a release branch also marks\nthe beginning of the development for the next version.  In contrast to that, only bug fixes can be merged in the release branch. At this point, the code contained in this\nbranch should be tested, so that bugs can be identified and fixed. The release manager can tag different beta versions\nduring the QA process (such as  1.6.0-beta1 ) to mark the code evolution as bug fixes are merged. Once the branch status\nseems to be stable enough to be released, a release candidate (RC) is tagged and tested ( 1.6.0-rc1 ). New RCs can be\ntagged as long as new issues are found and fixed. When no severe issues are found, the final release is tagged.  During the whole process the release manager will regularly merge back the release branch into  develop  so that bug\nfixes from the release branch will automatically become part of  develop  and the next Opencast version, without having\nto create an additional pull request. This is continued until the release branch for the next version is cut.  The releases themselves are not part of the release branch. Instead, the release manager branches off, makes the\nnecessary changes to the pom files (and possibly the UI) and creates a separate tagged commit.  Finally, after a release is done, more bug fixes may be added to the release branch. The release manager should identify\nif there are enough commits to be put into a maintenance release.  Even after an Opencast version has been released, more bugs may be found and fixes for them merged in the release\nbranch. When the release manager considers that the number or importance of such bug fixes is sufficient, he may decide\nto create a new maintenance release. The version  1.6.1  above is an example of that.  The branching structure for multiple versions does not look much more complicated:  develop  -----*---------*----*------------------------*------>\n               \\       /    / \\                      /\n        r/1.5.x *-----*----*------------*--->       /\n                       \\        \\        \\         /\n                  1.5.0 *        \\  1.5.1 *       /\n                                  \\              /\n                           r/1.6.x *------------*----->\n                                                 \\\n                                            1.6.0 *  As you can see, the same principle, the same structure and the same rules apply. The only noteworthy thing is that,\nafter a new release branch is cut, the old release branch will not be merged back into  develop . This means that when\na bug fix is relevant to several releases, a different pull request should be created for each of the release branches.",
            "title": "Git Repository Branching Model"
        },
        {
            "location": "/development/#release-process",
            "text": "As indicated above, the release cycle of a new Opencast version starts when a release branch is cut. The new features\nmerged into  develop  afterwards will be part of the next version, but not the one just cut.  This is why the position of release manager for the next Opencast version should be assigned at this point. The current\nrelease manager should therefore ask for volunteers in the mailing lists. For more details about the rights and\nresponsibilities of a release manager, please have a look at the  Release Manager Guide .",
            "title": "Release Process"
        },
        {
            "location": "/development/#preparations",
            "text": "The first phase of the release consists of adding new features and defining the release schedule. It is the duty of the\nrelease manager to orchestrate this. This does not necessarily mean that release managers merge or review pull requests,\nbut that they talk to developers and ensure the merge process is driven forward.",
            "title": "Preparations"
        },
        {
            "location": "/development/#release-schedule",
            "text": "Releases should happen twice a year, usually within a time span of 9.5 months between the cut of the previous release\nbranch and the final release. The release manager should create a release schedule as soon as possible, identifying when\nthe release branch is cut and when the final release will happen. Additionally, he should coordinate with the QA manager\nto identify phases for internal and public testing.  Usually a release schedule will look like this:  October 1st                     Cutting the release branch\nOctober 1st - 22nd              Internal QA phase\nOctober 22nd-November 5th       Public QA phase\nNovember 5th - 26th             Additional bug fixing phase\nNovember 26th - December 10th   Final QA phase (*)\nDecember 15th                   Release of Opencast x.y  (*) marks the phase where the release is apparently ready to go and has no release blockers left. The additional time is\nto ensure that there is time to fix any serious bug found during this final phase.",
            "title": "Release Schedule"
        },
        {
            "location": "/development/#release-branch",
            "text": "The release branch is created from  develop . The release branch is named  r/A.B.x  (e.g.  r/2.1.x ) to indicate that it\nis the origin of all releases with the major and minor version of  A.B . The creation of the release branch marks the\nfeature freeze for a given version, as no more features can be merged into a release branch.  To ensure that all fixes that go into the release branch will become part of  develop  (and thus part of the next version\nof Opencast) with a minimum amount of work, the release manager will merge the release branch into  develop  on a\nregular basis. He may request assistance from certain developers in case of merge conflicts. This process continues until\nthe next release branch is cut.",
            "title": "Release Branch"
        },
        {
            "location": "/development/#tags",
            "text": "Git tags are used to mark explicit Opencast versions or releases. Here is how a release should look like in the history:  r/A.B.x  ------------(A)---->\n                       \\\n           A.B.0-beta1 (B)  To create a version based on a given state of the release branch (commit A), the release manager will branch off from\nthis commit, make the necessary version changes to all  pom.xml  files and to the UI and create a commit and a  signed \ngit tag on this commit. He would then push the commit and the tag (not the branch) to the community repository.  Fore more details about how to create release, have a look at the  Release Manager Guide .",
            "title": "Tags"
        },
        {
            "location": "/development/#beta-versionsrelease-candidates",
            "text": "A beta release ( A.B.C-betaX ) should be cut before the public QA phase. It indicates a specific version of Opencast for\nusers to test. It is expected to still have bugs. Beta releases should continue until all bugs with a severity of Blocker  have been fixed.  If the code seems to be ready for a release, a  release candidate  ( A.B.C-rcX ) should be cut for final testing. The\ncommit from which a release candidate is created is expected to become the final release if no severe bugs are found.",
            "title": "Beta Versions/Release Candidates"
        },
        {
            "location": "/development/#final-release",
            "text": "Once a release candidate seems to be stable during the QA phase (no issues left marked as  Blocker ), the release manager\nwill propose this release candidate to become the final release. If the proposal is approved (i.e. no serious bugs are\nfound before the proposal deadline is met), the final release is then created from the same commit the\nrelease candidate was cut from.",
            "title": "Final Release"
        },
        {
            "location": "/development/#maintenance-releases",
            "text": "After a final release, additional issues may show up. These issues may be fixed on the ongoing release branch and at\nsome point released as maintenance release.  There is usually no release schedule for maintenance releases. It is up to the release manager to decide when it is\nworthwhile to create a maintenance release with the fixes for bugs affecting a given release. He would then announce his\nintention to create such a release, cut a release candidate and, should no severe issues with this candidate show up, cut\nthe maintenance release.",
            "title": "Maintenance Releases"
        },
        {
            "location": "/development/#quality-assurance",
            "text": "As any piece of software, Opencast may contain bugs. It is the duty of the whole community to identify these bugs,\nreport them and possibly fix them to improve Opencast as product.  Additionally, before releasing a new version of Opencast, the current release manager and quality assurance manager will\ncoordinate test phases dedicated to new releases in order to identify possible problems ahead of time. The whole\ncommunity will be requested to participate in this testing.",
            "title": "Quality Assurance"
        },
        {
            "location": "/development/#reporting-bugs",
            "text": "If you identify any bugs, please report them! To do that, register yourself in the  Opencast\nJira  and create a new ticket. Please describe in detail how to reproduce the problem and\nespecially set the  Affects Version  and \"Fix Version\", where  Fix Version  should be the next Opencast release.  If in doubt of any items in the ticket, please assign it for review to either the current release manager or to the\nquality assurance manager. They will check the issue fields and adjust  fix version ,  severity , etc. if necessary.",
            "title": "Reporting Bugs"
        },
        {
            "location": "/development/#security-issues",
            "text": "If you discover a problem that has severe implications for system security, please do not publish these information on\nlist. Instead, send a report of the problem to  security@opencast.org . The message will be forwarded to the private\ncommitters list, where the issue will be discussed. Once a patch for the problem is ready, a security notice will be\nreleased along with it.",
            "title": "Security Issues"
        },
        {
            "location": "/development/#unit-tests",
            "text": "All Opencast modules should have built-in unit tests to check that they are actually doing what they are supposed to do\nand that code patches do not break the existing functionality. These tests are automatically run whenever the project is\nbuilt. If building repeatedly fails due to test failures, then something is most likely wrong. Please report this as a\nsevere bug.",
            "title": "Unit Tests"
        },
        {
            "location": "/development/#user-tests",
            "text": "Before each major release, the release and quality assurance managers will ask the whole community to participate in\nthe execution of a set of manual tests. These tests are designed to check that important functionalities of Opencast\nwork as expected even if users are in slightly different environments or choose different methods to achieve a certain\ngoal.  Such a call for participation will usually be raised both on the lists, the technical and the adopters meeting.  If it\nis possible for you to participate, please do so. Identifying possible problems early will immensely benefit the release\nprocess.",
            "title": "User Tests"
        },
        {
            "location": "/development/#test-server",
            "text": "Some institutions provide public testing infrastructure for Opencast. Use them to try out the most recent development\nversion of Opencast. They are meant for testing. Do not fear to break them.  If you manage to do it, please contact the\nQA manager or send a notice to the list.  Remember that they are usually not running a stable version of Opencast but the latest development release (beta version\nor release candidate) instead. If you discover any bugs on these systems, please take a minute to report them.",
            "title": "Test Server"
        },
        {
            "location": "/reviewing-and-merging/",
            "text": "Reviewing, Merging and Declining Pull Requests\n\n\nBefore a patch is merged into an official branch, it needs to be reviewed by a committer. During a\nreview, the reviewer is tries to make sure that the patch merges without conflicts, that it works as expected and that\nit does not break anything else.\n\n\nIf the reviewer discovers any kind of issue, he should leave a comment in the pull request view of BitBucket and let the\ncontributor fix the problem. Reviewer and contributor should work together to fix any problem with the pull requests\nbefore it is ready to go into the codebase.\n\n\nReviewing Rules\n\n\n\n\nReviews and merges need to be done by committers.\n\n\nReviewers should come from a different institution than the contributor.\n\n\nTo assign yourself as a reviewer, add a comment to the BitBucket pull request like \u201c\nI will //review// this\n\u201d. The\n   use of \n//review//\n will make the \npull request filter\n pick up the author of this\n   comment as reviewer.\n\n\nPull requests for bug fixes (t/MH-XXXXX-...) may be reviewed and merged out of order.\n\n\nFeature pull requests have to be merged in order unless their contributor or reviewer decide to temporarily skip it.\n   Such a decision has to be justified by the existence of unresolved issues in that particular pull request.\n\n\nThere is a so-called \u201cmerge ticket\u201d in Jira for \ndevelop\n and for each release branch. Committers must not merge code\n   into these branches unless they are the assignee of the corresponding ticket.\n\n\nBy default, the merge ticket for \ndevelop\n should be always assigned to the reviewer of the next feature pull request\n   to be merged.\n\n\nThe merge ticket for \ndevelop\n, can be temporarily taken by anyone for merging a bug fix after coordinating this with\n   the current assignee of the ticket\n\n\nNo features can be merged in the release branches, so the merge tickets corresponding to a release branch will be\n   unassigned by default. Reviewers merging bug fixes must assign the ticket to themselves before doing so, and then\n   leave it unassigned after finishing.\n\n\nThe release ticket should not be unassigned for longer than 72 hours in which case the release manager should assign\n   it to the reviewer of the next pull request in line.\n\n\nAfter taking up a review (or being assigned to one), a basic review has to be done within the following 14 days for a\n   bug fix or 21 days for a feature. A basic review means that either some issues should be pointed out or the pull\n   request should be approved.\n\n\nNo pull request shall be without a reviewer for more than 14 days. If no committer is willing to take up the review\n   on their own, the review will be assigned.\n\n\nAny committer may merge an arbitrary set of \napproved\n pull requests, even if he is not the official reviewer, given\n   that:\n\n\nThe committer sends an announcement to the development list 24 hours in advance, including a list of the pull\n  requests to be merged and no other committer objects to that.\n\n\nThe committer checks that all the patches are working (which basically means to review the patch set as a whole).\n\n\n\n\n\n\nA reviewer may decline a pull request if issues were pointed out but were neither fixed nor discussed for more than\n   14 days. It is generally suggested to try to contact the contributor before declining the pull request and to\n   additionally bring the problem up at the technical meeting.\n\n\n\n\nReviewing a Pull Request\n\n\nThere is no list of things you are required to do as reviewer of a pull request. Our primary goals in doing reviews for\nall pull requests are to ensure that:\n\n\n\n\nThere are no bugs in the pull request\n\n\nThe feature works as advertised\n\n\nIt does not break any other features\n\n\n\n\n\n\nThere are no obvious legal problems\n\n\nLicenses seem to be fine\n\n\nLicenses are added to the \nNOTICES\n file\n\n\n\n\n\n\nFeature documentation is in place\n\n\nAn upgrade path exists (usually relevant for database changes)\n\n\n\n\nThe exact review process heavily depends on the type, size and purpose of the pull request. For example, it does not\nmake sense to run the unit or integration tests for pull requests containing documentation only. Instead, reviewers\nshould run \nmkdocs\n to build the documentation.\n\n\nHere are some things a reviewer should usually do:\n\n\n\n\nCheck if code looks sensible (e.g. no nonsensical files, no obvious formatting errors, no large binary files, \u2026)\n\n\nPerform the merge locally to make sure there are no conflicts\n\n\nBuild Opencast with the \n-Dall\n flag (build all modules) and tests enabled (default). If you have some more time\n   (e.g. lunch break), clear your local Maven repository (usually \n~/.m2\n) before starting the build process\n\n\nLocally run Opencast to make sure it still works after the merge\n\n\nMake sure the issue has been fixed (as described in the pull request and/or the Jira ticket) or the feature does\n   what it is supposed to\n\n\nCheck and build the documentation",
            "title": "Reviewing, Merging and Declining Pull Requests"
        },
        {
            "location": "/reviewing-and-merging/#reviewing-merging-and-declining-pull-requests",
            "text": "Before a patch is merged into an official branch, it needs to be reviewed by a committer. During a\nreview, the reviewer is tries to make sure that the patch merges without conflicts, that it works as expected and that\nit does not break anything else.  If the reviewer discovers any kind of issue, he should leave a comment in the pull request view of BitBucket and let the\ncontributor fix the problem. Reviewer and contributor should work together to fix any problem with the pull requests\nbefore it is ready to go into the codebase.",
            "title": "Reviewing, Merging and Declining Pull Requests"
        },
        {
            "location": "/reviewing-and-merging/#reviewing-rules",
            "text": "Reviews and merges need to be done by committers.  Reviewers should come from a different institution than the contributor.  To assign yourself as a reviewer, add a comment to the BitBucket pull request like \u201c I will //review// this \u201d. The\n   use of  //review//  will make the  pull request filter  pick up the author of this\n   comment as reviewer.  Pull requests for bug fixes (t/MH-XXXXX-...) may be reviewed and merged out of order.  Feature pull requests have to be merged in order unless their contributor or reviewer decide to temporarily skip it.\n   Such a decision has to be justified by the existence of unresolved issues in that particular pull request.  There is a so-called \u201cmerge ticket\u201d in Jira for  develop  and for each release branch. Committers must not merge code\n   into these branches unless they are the assignee of the corresponding ticket.  By default, the merge ticket for  develop  should be always assigned to the reviewer of the next feature pull request\n   to be merged.  The merge ticket for  develop , can be temporarily taken by anyone for merging a bug fix after coordinating this with\n   the current assignee of the ticket  No features can be merged in the release branches, so the merge tickets corresponding to a release branch will be\n   unassigned by default. Reviewers merging bug fixes must assign the ticket to themselves before doing so, and then\n   leave it unassigned after finishing.  The release ticket should not be unassigned for longer than 72 hours in which case the release manager should assign\n   it to the reviewer of the next pull request in line.  After taking up a review (or being assigned to one), a basic review has to be done within the following 14 days for a\n   bug fix or 21 days for a feature. A basic review means that either some issues should be pointed out or the pull\n   request should be approved.  No pull request shall be without a reviewer for more than 14 days. If no committer is willing to take up the review\n   on their own, the review will be assigned.  Any committer may merge an arbitrary set of  approved  pull requests, even if he is not the official reviewer, given\n   that:  The committer sends an announcement to the development list 24 hours in advance, including a list of the pull\n  requests to be merged and no other committer objects to that.  The committer checks that all the patches are working (which basically means to review the patch set as a whole).    A reviewer may decline a pull request if issues were pointed out but were neither fixed nor discussed for more than\n   14 days. It is generally suggested to try to contact the contributor before declining the pull request and to\n   additionally bring the problem up at the technical meeting.",
            "title": "Reviewing Rules"
        },
        {
            "location": "/reviewing-and-merging/#reviewing-a-pull-request",
            "text": "There is no list of things you are required to do as reviewer of a pull request. Our primary goals in doing reviews for\nall pull requests are to ensure that:   There are no bugs in the pull request  The feature works as advertised  It does not break any other features    There are no obvious legal problems  Licenses seem to be fine  Licenses are added to the  NOTICES  file    Feature documentation is in place  An upgrade path exists (usually relevant for database changes)   The exact review process heavily depends on the type, size and purpose of the pull request. For example, it does not\nmake sense to run the unit or integration tests for pull requests containing documentation only. Instead, reviewers\nshould run  mkdocs  to build the documentation.  Here are some things a reviewer should usually do:   Check if code looks sensible (e.g. no nonsensical files, no obvious formatting errors, no large binary files, \u2026)  Perform the merge locally to make sure there are no conflicts  Build Opencast with the  -Dall  flag (build all modules) and tests enabled (default). If you have some more time\n   (e.g. lunch break), clear your local Maven repository (usually  ~/.m2 ) before starting the build process  Locally run Opencast to make sure it still works after the merge  Make sure the issue has been fixed (as described in the pull request and/or the Jira ticket) or the feature does\n   what it is supposed to  Check and build the documentation",
            "title": "Reviewing a Pull Request"
        },
        {
            "location": "/release-manager/",
            "text": "Release Manager Guide\n\n\nTODO: Copy over from \nwiki",
            "title": "Release Manager"
        },
        {
            "location": "/release-manager/#release-manager-guide",
            "text": "TODO: Copy over from  wiki",
            "title": "Release Manager Guide"
        },
        {
            "location": "/license/",
            "text": "Licenses and Legal Matters\n\n\n\n\nThis is a guide from developers for developers and therefore not an official legal document. We try to be as accurate\nas possible but cannot guarantee that there are no mistakes. If in doubt, please send a question to the Opencast\ndeveloper mailing list, to the Opencast Board or to the Apereo Foundation, preferably in that order.\n\n\n\n\nWhich Licenses May I Use for Opencast?\n\n\nAll libraries that are used in Opencast need to be compatible with the Educational Community License version 2.0:\n\n\n\n\n\n\nIn short, if the license is on this list, it is fine to use the library:\n\n\n\n\nhttp://www.apache.org/legal/resolved.html#category-a\n\n\n\n\n\n\n\n\nIf instead it is listed here, we cannot use it:\n\n\n\n\nhttp://www.apache.org/legal/resolved.html#category-x\n\n\n\n\n\n\n\n\nEverything else needs to go to the Apereo lawyers.\n\n\nHere is the slightly longer section from the \u201eApereo Licensing & Intellectual Property Practices\u201c page:\n\n\n\n\nThird-Party Content\n\n\nThird-party content (source code, binary artifacts like libraries, documentation, etc.) is anything that was not\nsubmitted directly to Apereo or that is not covered under an ICLA, CCLA, or SGLA. Apereo projects can use third-party\ncontent as long as the project is in compliance with the license under which the content is acquired, and as long as\nuse of the third-party content does not violate Apereo's own licensing and policies. Use of any third-party content\nnot available under one of the licenses on ASF's \"Category A\" list must first be reviewed by the project\u2019s governance\nbody since this has implications for how the derivative work can be used. See the Apereo documentation on Third-Party\nLicenses for more details.\n\n\nThird-party content should be handled much differently from Apereo content. Copyright and license notices inside\nsource files should not be modified and the standard Apereo source header should not be added. Licenses for the\nthird-party content should be included with the distribution and appropriate notices should be included in the NOTICE\nfile. Minor modifications to third-party sources should be licensed under the same terms as the original third-party\nsource, while major modifications to third-party sources should be handed on a case-by-cases by the project's\ngovernance body.\n\n\n\n\nHow To Label Third Party Libraries\n\n\nThird party libraries that are used within an Opencast system in production need to be listed in the \nNOTICES\n file,\nwhich can be found in the root directory of our code repository. Libraries and tools that are only used for testing or\nbuilding the project, or are run via system call, do not need to be listed (e.g. maven, maven plugins, junit, ...).\n\n\nJavaScript Libraries\n\n\nFor JavaScript libraries, list the file or folder that is included and give a short statement about the copyright and\nlicense. This can usually be taken from the copyright header at the top of the library.\n\n\nExample:\n\n\nmodules/matterhorn-admin-ui-ng/src/main/webapp/lib/angular/*\n  AngularJS v1.3.6\n  (c) 2010-2014 Google, Inc. http://angularjs.org\n  License: MIT\n\n\n\nJava Libraries / Maven Dependencies\n\n\nJava dependencies are listed pre module. Maven provides some helpful tools to list dependencies and even report\nlibraries. Have a look at the output of \nmvn dependency:list\n and \nmvn dependency:tree\n or generate a full report for a\nmodule using:\n\n\nmvn -s settings.xml project-info-reports:dependencies\n\n\n\nThis will create a file \ntarget/site/dependencies.html\n containing a full report, including the library versions and\nlicenses.\n\n\nFinally, add the library and license to the \nNOTICES\n file in the form:\n\n\nrn-workflow-service-remote\n  GroupId       ArtifactId    License\n  commons-io    commons-io    The Apache Software License, Version 2.0",
            "title": "Licenses and Legal Matters"
        },
        {
            "location": "/license/#licenses-and-legal-matters",
            "text": "This is a guide from developers for developers and therefore not an official legal document. We try to be as accurate\nas possible but cannot guarantee that there are no mistakes. If in doubt, please send a question to the Opencast\ndeveloper mailing list, to the Opencast Board or to the Apereo Foundation, preferably in that order.",
            "title": "Licenses and Legal Matters"
        },
        {
            "location": "/license/#which-licenses-may-i-use-for-opencast",
            "text": "All libraries that are used in Opencast need to be compatible with the Educational Community License version 2.0:    In short, if the license is on this list, it is fine to use the library:   http://www.apache.org/legal/resolved.html#category-a     If instead it is listed here, we cannot use it:   http://www.apache.org/legal/resolved.html#category-x     Everything else needs to go to the Apereo lawyers.  Here is the slightly longer section from the \u201eApereo Licensing & Intellectual Property Practices\u201c page:   Third-Party Content  Third-party content (source code, binary artifacts like libraries, documentation, etc.) is anything that was not\nsubmitted directly to Apereo or that is not covered under an ICLA, CCLA, or SGLA. Apereo projects can use third-party\ncontent as long as the project is in compliance with the license under which the content is acquired, and as long as\nuse of the third-party content does not violate Apereo's own licensing and policies. Use of any third-party content\nnot available under one of the licenses on ASF's \"Category A\" list must first be reviewed by the project\u2019s governance\nbody since this has implications for how the derivative work can be used. See the Apereo documentation on Third-Party\nLicenses for more details.  Third-party content should be handled much differently from Apereo content. Copyright and license notices inside\nsource files should not be modified and the standard Apereo source header should not be added. Licenses for the\nthird-party content should be included with the distribution and appropriate notices should be included in the NOTICE\nfile. Minor modifications to third-party sources should be licensed under the same terms as the original third-party\nsource, while major modifications to third-party sources should be handed on a case-by-cases by the project's\ngovernance body.",
            "title": "Which Licenses May I Use for Opencast?"
        },
        {
            "location": "/license/#how-to-label-third-party-libraries",
            "text": "Third party libraries that are used within an Opencast system in production need to be listed in the  NOTICES  file,\nwhich can be found in the root directory of our code repository. Libraries and tools that are only used for testing or\nbuilding the project, or are run via system call, do not need to be listed (e.g. maven, maven plugins, junit, ...).",
            "title": "How To Label Third Party Libraries"
        },
        {
            "location": "/license/#javascript-libraries",
            "text": "For JavaScript libraries, list the file or folder that is included and give a short statement about the copyright and\nlicense. This can usually be taken from the copyright header at the top of the library.  Example:  modules/matterhorn-admin-ui-ng/src/main/webapp/lib/angular/*\n  AngularJS v1.3.6\n  (c) 2010-2014 Google, Inc. http://angularjs.org\n  License: MIT",
            "title": "JavaScript Libraries"
        },
        {
            "location": "/license/#java-libraries-maven-dependencies",
            "text": "Java dependencies are listed pre module. Maven provides some helpful tools to list dependencies and even report\nlibraries. Have a look at the output of  mvn dependency:list  and  mvn dependency:tree  or generate a full report for a\nmodule using:  mvn -s settings.xml project-info-reports:dependencies  This will create a file  target/site/dependencies.html  containing a full report, including the library versions and\nlicenses.  Finally, add the library and license to the  NOTICES  file in the form:  rn-workflow-service-remote\n  GroupId       ArtifactId    License\n  commons-io    commons-io    The Apache Software License, Version 2.0",
            "title": "Java Libraries / Maven Dependencies"
        },
        {
            "location": "/proposal-log/",
            "text": "Opencast Proposals\n\n\nAll important decisions for Opencast Matterhorn have to be made on list. To do that committers may send proposals\n(marked with #proposal) to list on which other committers may then vote. Opencast uses lazy consensus meaning that no\nresponse signals agreement. Apart from that committers may vote with:\n\n\n\n\n+1\n yes, agree - also willing to help bring about the proposed action\n\n\n+0\n yes, agree - not willing or able to help bring about the proposed action\n\n\n-0\n no, disagree - but will not oppose the action going forward\n\n\n-1\n veto, disagree - opposes the action going forward and must propose an alternate action to address the issue or a\n   justification for not addressing the issue\n\n\n\n\nPassed Proposals\n\n\nMoving away from the 3rd party scripts\n\n\nProposed by Greg Logan \ngregorydlogan@gmail.com\n, Passed on Fri, 24 Jul 2015 15:00:00 UTC\n\n\nHi folks,\n\nAs it stands right now we depend on the 3rd party tool script to\ninstall a great many of our 3rd party dependencies.  These are\nutilities like tesseract, ffmpeg, sox, etc.  This script is maintained\nby Matjaz, in his own time.  I'd like to take a moment to thank him\nfor a doing a great job on a particularly annoying aspect of\nsupporting our work!  I know it hasn't been easy, especially\nsupporting vast number of different OS versions!\n\nWith the release of 2.0 I noticed that our 3rd party tool script is\nbecoming both a little out of date, and difficult to maintain.  I took\na quick look around and it seems like *most* of our dependencies are\navailable from normal distribution repositories for Debian based\nsystems, and I'm told that there is a similar situation for Redhat\nbased systems.  I am unsure of how many of our users are running\nMatterhorn on Mac, but I would hope that our developers who are\nworking on Mac would be able to provide instructions and/or binaries\nfor those users.  The only dependency where there might be a universal\nsticking point is ffmpeg (due to patent concerns), however ffmpeg\nbuilds a full static binary with each release, so I assume we can\neither depend on this and/or cache them somewhere.\n\nWhat this means is that we can potentially remove the 3rd party script\nfrom our repository.  I hereby #propose we find a way to do that,\nwhich would remove the 3rd party script from the repository and\nreplace it with a number of new steps in the install documentation.\n\n\n\nRequirement Specification\n\n\nProposed by Lars Kiesow \nlkiesow@uos.de\n, Passed on Thu, 16 Apr 2015 15:55:31 UTC\n\n\nOn list or IRC we often see that people do not really know the current\nrequirements for a specific version of Opencast Matterhorn. Of course\nthere are the pom.xml files specifying internal dependencies, but there\nis nothing for 3rd-party-tools, ...\n\nIt would be nice to add a file specifying these requirements in a\nformat that is easy to parse and can hence be used for automatic\nscripts to generate dependency lists, ...\n\nThat is why I hereby #propose to add a requirements.xml file that\nspecifies the requirements for Opencast Matterhorn:\n - Required tools including versions\n - Which modules require which tools\n - Which modules conflict with each other (negative requirement)\n\nThis is mainly what is not specified by the pom.xml files yet.\n\n\n\nJira Clean-Up (Tags VS Labels)\n\n\nProposed by Lars Kiesow \nlkiesow@uos.de\n, Passed on Thu, 19. Mar 2015 15:43:20 UTC\n\n\n\u2026then hereby I officially #propose removing the labels from Jira.\n\n\n\nFor more details, have a look at the mail thread at:\n\n\nhttps://groups.google.com/a/opencast.org/forum/#!topic/matterhorn/vIdWQkZmbdQ\n\n\n\nFFmpeg Update\n\n\nProposed by Lars Kiesow \nlkiesow@uos.de\n, Passed on Sat, 14 Mar 2015 22:12:18 UTC\n\n\nLooking at the FFmpeg project for the last two years, you will notice\nthat they developed a pretty stable release cycle with a release of a\nnew stable version approximately every three month.\n\nTo stop us from having to propose an update again and again, I hereby\npropose the following general rule for our support of FFmpeg:\n\n  A Matterhorn release will oficially support the latest stable\n  version of FFmpeg released at the time the release branch is cut and\n  all other FFmpeg versions with the same major version number released\n  afterwards.\n\nFor example, for Matterhorn 2 this would mean that we will officially\nsupport FFmpeg 2.5.4 and all later 2.x versions like 2.6 which has\nbeen released on the 7th of March or a possible 2.7 onece it is\nreleased. We would, however, not necessarily support an FFmpeg 3 as it\n*might* come with an interface change that *could* break compatibility.\n\nThat obviously does not mean that older versions of FFmpeg just stop\nworking. In fact, most parts of the default Matterhorn configuration\nshould at the moment still work with FFmpeg 1.x but we will not test or\nfix compatibility problems.\n\n\n\nProposal Log\n\n\nProposed by Lars Kiesow \nlkiesow@uos.de\n, Passed on Sat, 14 Mar 2015 16:35:08 UTC\n\n\nIt would be wonderful if we had a central place to look up the proposals\nthat have passed.\n\nThat is why I hereby propose that:\n\n - We create a proposal log in our new documentation containing all\n   proposals that have passed on list.\n\n - A proposal will become effective only after it is written down in\n   that log. That should usually be done by the person who sent out\n   that proposal.\n\nThis will, of course, not affect the existing decision making rules\n(proposal on list, marked with #proposal, lazy consensus after three\ndays, no -1, ...)",
            "title": "Proposal Log"
        },
        {
            "location": "/proposal-log/#opencast-proposals",
            "text": "All important decisions for Opencast Matterhorn have to be made on list. To do that committers may send proposals\n(marked with #proposal) to list on which other committers may then vote. Opencast uses lazy consensus meaning that no\nresponse signals agreement. Apart from that committers may vote with:   +1  yes, agree - also willing to help bring about the proposed action  +0  yes, agree - not willing or able to help bring about the proposed action  -0  no, disagree - but will not oppose the action going forward  -1  veto, disagree - opposes the action going forward and must propose an alternate action to address the issue or a\n   justification for not addressing the issue",
            "title": "Opencast Proposals"
        },
        {
            "location": "/proposal-log/#passed-proposals",
            "text": "",
            "title": "Passed Proposals"
        },
        {
            "location": "/proposal-log/#moving-away-from-the-3rd-party-scripts",
            "text": "Proposed by Greg Logan  gregorydlogan@gmail.com , Passed on Fri, 24 Jul 2015 15:00:00 UTC  Hi folks,\n\nAs it stands right now we depend on the 3rd party tool script to\ninstall a great many of our 3rd party dependencies.  These are\nutilities like tesseract, ffmpeg, sox, etc.  This script is maintained\nby Matjaz, in his own time.  I'd like to take a moment to thank him\nfor a doing a great job on a particularly annoying aspect of\nsupporting our work!  I know it hasn't been easy, especially\nsupporting vast number of different OS versions!\n\nWith the release of 2.0 I noticed that our 3rd party tool script is\nbecoming both a little out of date, and difficult to maintain.  I took\na quick look around and it seems like *most* of our dependencies are\navailable from normal distribution repositories for Debian based\nsystems, and I'm told that there is a similar situation for Redhat\nbased systems.  I am unsure of how many of our users are running\nMatterhorn on Mac, but I would hope that our developers who are\nworking on Mac would be able to provide instructions and/or binaries\nfor those users.  The only dependency where there might be a universal\nsticking point is ffmpeg (due to patent concerns), however ffmpeg\nbuilds a full static binary with each release, so I assume we can\neither depend on this and/or cache them somewhere.\n\nWhat this means is that we can potentially remove the 3rd party script\nfrom our repository.  I hereby #propose we find a way to do that,\nwhich would remove the 3rd party script from the repository and\nreplace it with a number of new steps in the install documentation.",
            "title": "Moving away from the 3rd party scripts"
        },
        {
            "location": "/proposal-log/#requirement-specification",
            "text": "Proposed by Lars Kiesow  lkiesow@uos.de , Passed on Thu, 16 Apr 2015 15:55:31 UTC  On list or IRC we often see that people do not really know the current\nrequirements for a specific version of Opencast Matterhorn. Of course\nthere are the pom.xml files specifying internal dependencies, but there\nis nothing for 3rd-party-tools, ...\n\nIt would be nice to add a file specifying these requirements in a\nformat that is easy to parse and can hence be used for automatic\nscripts to generate dependency lists, ...\n\nThat is why I hereby #propose to add a requirements.xml file that\nspecifies the requirements for Opencast Matterhorn:\n - Required tools including versions\n - Which modules require which tools\n - Which modules conflict with each other (negative requirement)\n\nThis is mainly what is not specified by the pom.xml files yet.",
            "title": "Requirement Specification"
        },
        {
            "location": "/proposal-log/#jira-clean-up-tags-vs-labels",
            "text": "Proposed by Lars Kiesow  lkiesow@uos.de , Passed on Thu, 19. Mar 2015 15:43:20 UTC  \u2026then hereby I officially #propose removing the labels from Jira.  For more details, have a look at the mail thread at:  https://groups.google.com/a/opencast.org/forum/#!topic/matterhorn/vIdWQkZmbdQ",
            "title": "Jira Clean-Up (Tags VS Labels)"
        },
        {
            "location": "/proposal-log/#ffmpeg-update",
            "text": "Proposed by Lars Kiesow  lkiesow@uos.de , Passed on Sat, 14 Mar 2015 22:12:18 UTC  Looking at the FFmpeg project for the last two years, you will notice\nthat they developed a pretty stable release cycle with a release of a\nnew stable version approximately every three month.\n\nTo stop us from having to propose an update again and again, I hereby\npropose the following general rule for our support of FFmpeg:\n\n  A Matterhorn release will oficially support the latest stable\n  version of FFmpeg released at the time the release branch is cut and\n  all other FFmpeg versions with the same major version number released\n  afterwards.\n\nFor example, for Matterhorn 2 this would mean that we will officially\nsupport FFmpeg 2.5.4 and all later 2.x versions like 2.6 which has\nbeen released on the 7th of March or a possible 2.7 onece it is\nreleased. We would, however, not necessarily support an FFmpeg 3 as it\n*might* come with an interface change that *could* break compatibility.\n\nThat obviously does not mean that older versions of FFmpeg just stop\nworking. In fact, most parts of the default Matterhorn configuration\nshould at the moment still work with FFmpeg 1.x but we will not test or\nfix compatibility problems.",
            "title": "FFmpeg Update"
        },
        {
            "location": "/proposal-log/#proposal-log",
            "text": "Proposed by Lars Kiesow  lkiesow@uos.de , Passed on Sat, 14 Mar 2015 16:35:08 UTC  It would be wonderful if we had a central place to look up the proposals\nthat have passed.\n\nThat is why I hereby propose that:\n\n - We create a proposal log in our new documentation containing all\n   proposals that have passed on list.\n\n - A proposal will become effective only after it is written down in\n   that log. That should usually be done by the person who sent out\n   that proposal.\n\nThis will, of course, not affect the existing decision making rules\n(proposal on list, marked with #proposal, lazy consensus after three\ndays, no -1, ...)",
            "title": "Proposal Log"
        },
        {
            "location": "/packaging/",
            "text": "Packaging Guidelines\n\n\nThis page is intended as a guideline for packagers. It may help to figure out where to place parts of Matterhorn.  The\nlocations, etc. proposed here should never overrule the official packaging guides for a specific operating system or\ndistribution.  If in doubt follow the guides for your distribution like for example the \nFedora Packaging\nGuidelines\n\n\nIntroduction\n\n\nIn a Unix file system there are different places for different types of data. Executables, for example, may be placed in\n\n/usr/bin\n, libraries in \n/usr/lib\n, etc. These places are defined by the operating system distributor and the\n\nFilesystem Hierarchy Standard\n. Latter is followed by almost every major\ndistributor, but not everything in there is clearly defined.\n\n\nEspecially software which is installed automatically\u2013for example software from RPM or DEB repositories\u2013should follow\nthese rules so conflicts are minimized and the user will have one place to look for one kind of data. For example if you\nare searching for a system-wide configuration file for any software on Linux every user will always look in \n/etc\n.\n\n\nIf you want to package Matterhorn use the following documentations to decide where to place Matterhorn:\n\n\n\n\nDistribution guidelines like the \nFedora Packaging Guidelines\n\n\nFilesystem Hierarchy Standard\n\n\nThis Guide\n\n\n\n\nLocations To Use\n\n\nThe following locations should be used for Matterhorn and its related data:\n\n\n\n\n/usr/share/matterhorn\n:\n   Software and data not modified by Matterhorn. This includes felix, the matterhorn modules and external libraries.\n\n\n/etc/matterhorn\n:\n   Matterhorn related configuration files (Felix and service configuration, workflows, encoding profiles, etc.)\n\n\n/var/log/matterhorn\n:\n   The Matterhorn logfiles. Consider to enable logrotate for this directory.\n\n\n/srv/matterhorn\n or \n/var/lib/matterhorn\n:\n   Matterhorn storage, including the recordings, the archive, the Solr indexes, etc. You may use one of these\n   directories or both. For more details have a look at the explanation below and the discussion in the comments.\n\n\n/tmp/matterhorn\n:\n   Temporary data which are not necessarily preserved between reboots. This includes the felix-cache and other temporary\n   data.\n\n\n/usr/sbin/matterhorn\n:\n   Matterhorn startscript\n\n\n/etc/init.d/matterhorn\n\n   SysV-Initscript (if necessary)\n\n\n\n\nReasoning for these Locations\n\n\n/usr/share/matterhorn \u2013 Matterhorn Software Components\n\n\nThe Filesystem Hierarchy Standard states that \u201c\nThe /usr/share hierarchy is for all read-only architecture independent\ndata files.\n\u201d and that \u201c\nAny program or package which contains or requires data that does not need to be modified should\nstore that data in /usr/share\n\u201d.  It is also used for this purpose by cups, emacs, cmake, pulseaudio, gimp, \u2026 It sould\nbe used for felix.jar and all the modules (lib directory)\n\n\n/etc/matterhorn \u2013 Matterhorn Configuration\n\n\nThe Filesystem Hierarchy Standard states that \u201c\nThe /etc hierarchy contains configuration files. A \"configuration file\"\nis a local file used to control the operation of a program; it must be static and cannot be an executable binary.\n\u201d\n\n\n/var/log/matterhorn/ \u2013 Matterhorn Logs\n\n\nThe Filesystem Hierarchy Standard states that \u201c\nThis directory contains miscellaneous log files. Most logs must be\nwritten to this directory or an appropriate subdirectory.\n\u201d\n\n\n/srv/matterhorn and/or /var/lib/matterhorn/ \u2013 Data modified by Matterhorn\n\n\nAbout this the Filesystem Hierarchy Standard says that \u201c\nThis hierarchy holds state information pertaining to an\napplication or the system. State information is data that programs modify while they run, \u2026\n\u201d also \u201c\n/var/lib/\n is\nthe location that must be used for all distribution packaging support\u2026\n\u201d\n\n\nWhy Not Use /opt For Packages\n\n\nWhile it is ok to place software in \n/opt\n if you install the manually as \n/opt\n is intended to be used for \u201c\nAdd-on\napplication software\n\u201d by the Filesystem Hierarchy Standard, it should never be used for automatic installations (RPMs\nDebian packages, \u2026).. The Fedora Packaging Guidelines for example are pretty clear about this:\n\n\n\u201c*No Files or Directories under /srv, /opt, or /usr/local [\u2026] In addition, no Fedora package can have any files or\ndirectories under /opt or /usr/local, as these directories are not permitted to be used by Distributions in the FHS.\n\n\nThe reason for this is that the FHS is handing control of the directory structure under /opt to the system administrator\nby stating that \u201c\nDistributions [\u2026] must not modify or delete software installed by the local system administrator \u2026\n\u201d.\n\n\nThat is something you cannot guarantee with automatic installations. For example if you use RPMs, the only way to do\nthis would be to mark every single file (binaries, modules, assets, \u2026) as configuration files which are not to be\nreplaced in case they are modified. It is quite obvious that this would be a a really bad idea leading to a number of\nfurther problems.\n\n\nNotice For System Operators\n\n\nThis guide is supposed to defines default locations for a matterhorn system. It does not restrict your own system\nconfiguration.\n\n\nFor a Matterhorn system it is for example quite common to mount an external storage (NFS, \u2026) and use it as storage for\nMatterhorn. You do not have to mount it to \n/var/lib/matterhorn\n if you do not want to. Instead, mount it in /media or\nwherever you want\u2013it is your system afterall\u2013and either change the Matterhorn configuration to use the directory of your\ndirectly, or put appropriate symlinks in \n/var/lib/matterhorn\n. This is, however, system specific and should not be done\nfor packages.",
            "title": "Packaging"
        },
        {
            "location": "/packaging/#packaging-guidelines",
            "text": "This page is intended as a guideline for packagers. It may help to figure out where to place parts of Matterhorn.  The\nlocations, etc. proposed here should never overrule the official packaging guides for a specific operating system or\ndistribution.  If in doubt follow the guides for your distribution like for example the  Fedora Packaging\nGuidelines",
            "title": "Packaging Guidelines"
        },
        {
            "location": "/packaging/#introduction",
            "text": "In a Unix file system there are different places for different types of data. Executables, for example, may be placed in /usr/bin , libraries in  /usr/lib , etc. These places are defined by the operating system distributor and the Filesystem Hierarchy Standard . Latter is followed by almost every major\ndistributor, but not everything in there is clearly defined.  Especially software which is installed automatically\u2013for example software from RPM or DEB repositories\u2013should follow\nthese rules so conflicts are minimized and the user will have one place to look for one kind of data. For example if you\nare searching for a system-wide configuration file for any software on Linux every user will always look in  /etc .  If you want to package Matterhorn use the following documentations to decide where to place Matterhorn:   Distribution guidelines like the  Fedora Packaging Guidelines  Filesystem Hierarchy Standard  This Guide",
            "title": "Introduction"
        },
        {
            "location": "/packaging/#locations-to-use",
            "text": "The following locations should be used for Matterhorn and its related data:   /usr/share/matterhorn :\n   Software and data not modified by Matterhorn. This includes felix, the matterhorn modules and external libraries.  /etc/matterhorn :\n   Matterhorn related configuration files (Felix and service configuration, workflows, encoding profiles, etc.)  /var/log/matterhorn :\n   The Matterhorn logfiles. Consider to enable logrotate for this directory.  /srv/matterhorn  or  /var/lib/matterhorn :\n   Matterhorn storage, including the recordings, the archive, the Solr indexes, etc. You may use one of these\n   directories or both. For more details have a look at the explanation below and the discussion in the comments.  /tmp/matterhorn :\n   Temporary data which are not necessarily preserved between reboots. This includes the felix-cache and other temporary\n   data.  /usr/sbin/matterhorn :\n   Matterhorn startscript  /etc/init.d/matterhorn \n   SysV-Initscript (if necessary)",
            "title": "Locations To Use"
        },
        {
            "location": "/packaging/#reasoning-for-these-locations",
            "text": "",
            "title": "Reasoning for these Locations"
        },
        {
            "location": "/packaging/#usrsharematterhorn-matterhorn-software-components",
            "text": "The Filesystem Hierarchy Standard states that \u201c The /usr/share hierarchy is for all read-only architecture independent\ndata files. \u201d and that \u201c Any program or package which contains or requires data that does not need to be modified should\nstore that data in /usr/share \u201d.  It is also used for this purpose by cups, emacs, cmake, pulseaudio, gimp, \u2026 It sould\nbe used for felix.jar and all the modules (lib directory)",
            "title": "/usr/share/matterhorn \u2013 Matterhorn Software Components"
        },
        {
            "location": "/packaging/#etcmatterhorn-matterhorn-configuration",
            "text": "The Filesystem Hierarchy Standard states that \u201c The /etc hierarchy contains configuration files. A \"configuration file\"\nis a local file used to control the operation of a program; it must be static and cannot be an executable binary. \u201d",
            "title": "/etc/matterhorn \u2013 Matterhorn Configuration"
        },
        {
            "location": "/packaging/#varlogmatterhorn-matterhorn-logs",
            "text": "The Filesystem Hierarchy Standard states that \u201c This directory contains miscellaneous log files. Most logs must be\nwritten to this directory or an appropriate subdirectory. \u201d",
            "title": "/var/log/matterhorn/ \u2013 Matterhorn Logs"
        },
        {
            "location": "/packaging/#srvmatterhorn-andor-varlibmatterhorn-data-modified-by-matterhorn",
            "text": "About this the Filesystem Hierarchy Standard says that \u201c This hierarchy holds state information pertaining to an\napplication or the system. State information is data that programs modify while they run, \u2026 \u201d also \u201c /var/lib/  is\nthe location that must be used for all distribution packaging support\u2026 \u201d",
            "title": "/srv/matterhorn and/or /var/lib/matterhorn/ \u2013 Data modified by Matterhorn"
        },
        {
            "location": "/packaging/#why-not-use-opt-for-packages",
            "text": "While it is ok to place software in  /opt  if you install the manually as  /opt  is intended to be used for \u201c Add-on\napplication software \u201d by the Filesystem Hierarchy Standard, it should never be used for automatic installations (RPMs\nDebian packages, \u2026).. The Fedora Packaging Guidelines for example are pretty clear about this:  \u201c*No Files or Directories under /srv, /opt, or /usr/local [\u2026] In addition, no Fedora package can have any files or\ndirectories under /opt or /usr/local, as these directories are not permitted to be used by Distributions in the FHS.  The reason for this is that the FHS is handing control of the directory structure under /opt to the system administrator\nby stating that \u201c Distributions [\u2026] must not modify or delete software installed by the local system administrator \u2026 \u201d.  That is something you cannot guarantee with automatic installations. For example if you use RPMs, the only way to do\nthis would be to mark every single file (binaries, modules, assets, \u2026) as configuration files which are not to be\nreplaced in case they are modified. It is quite obvious that this would be a a really bad idea leading to a number of\nfurther problems.",
            "title": "Why Not Use /opt For Packages"
        },
        {
            "location": "/packaging/#notice-for-system-operators",
            "text": "This guide is supposed to defines default locations for a matterhorn system. It does not restrict your own system\nconfiguration.  For a Matterhorn system it is for example quite common to mount an external storage (NFS, \u2026) and use it as storage for\nMatterhorn. You do not have to mount it to  /var/lib/matterhorn  if you do not want to. Instead, mount it in /media or\nwherever you want\u2013it is your system afterall\u2013and either change the Matterhorn configuration to use the directory of your\ndirectly, or put appropriate symlinks in  /var/lib/matterhorn . This is, however, system specific and should not be done\nfor packages.",
            "title": "Notice For System Operators"
        }
    ]
}